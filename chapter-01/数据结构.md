# 数据结构

## RMQ

ST 表可用于查询区间最值，需要 $O(n\log n)$ 时间预处理，查询可以在 *O*(1) 时间内完成。不支持修改

```cpp
const int maxn = 110000;
int st[maxn][21], lg[maxn], a[maxn];
void init(int n) { //下标范围 [1, n]，调用之前应当完成数组 a 的赋值
    lg[1] = 0;
    for (int i = 2; i <= n; ++i) lg[i] = lg[i >> 1] + 1;
    for (int i = 1; i <= n; ++i) st[i][0] = a[i];
    for (int j = 1; j <= lg[n]; ++j)
        for (int i = 1; i + (1 << j) - 1 <= n; ++i)
            st[i][j] = max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
}
inline int rmq(int L, int R) {
    int k = lg[R - L + 1];
    return max(st[L][k], st[R - (1 << k) + 1][k]);
}

```

## 单调栈

给出一个01矩阵，求全1子矩阵的个数。

1. 按行枚举子矩阵的底边，然后求以该行为底边的子矩阵的个数。
2. 预处理`int H[N][N]`：向上最大扩展全1的长度，然后就可以用单调栈解决。
3. 为了避免计算重复，单调栈时左闭右开即可。

![stack](C:\Users\12944\Desktop\code\ACM-ICPC\Contest-reference\References\mybook\src\images\stack.png)

按照上述思想也能够求最大子矩形的面积。

注意此做法能够优化到O(矩形1的数量)，因为可以直接枚举同一行的1的位置，考虑该行相邻列都是1的情况此时计算一次答案。【按照矩形的分布计算，因为一个位置是0就可以隔断子矩形】

```cpp
#include <bits/stdc++.h>

using namespace std;
const int N = 1e3 + 5;
using ll = int64_t;
int n, m, a[N][N];
int H[N][N]; // 向上最大扩展全1的长度
ll calc(int *h, int k) {//计算矩形个数 下标[0, k)
    stack<int> s;
    vector<int> l(k), r(k);
    for (int  i = k - 1; i >= 0; i--) {
        while (!s.empty() && h[i] <= h[s.top()]) l[s.top()] = i, s.pop();
        s.push(i);
    }
    while (!s.empty()) l[s.top()] = -1, s.pop();
    
    for (int  i = 0; i <= k - 1; i++) {
        while (!s.empty() && h[i] < h[s.top()]) r[s.top()] = i, s.pop();
        s.push(i);
    }
    while (!s.empty()) r[s.top()] = k, s.pop();
    ll res = 0;
    for (int  i = 0; i <= k - 1; i++)  res += (ll)h[i] * (i - l[i]) * (r[i] - i);
    return res;
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) 
        for (int j = 1; j <= m; j++) 
            scanf("%d", &a[i][j]);
    ll ans = 0;
    for (int i = 1; i <= n; i++)  {
        for (int j = 1; j <= m; j++) {
            if (a[i][j])
                H[i][j] = H[i-1][j] + 1;
            else
                H[i][j] = 0;
        }
        ans += calc(H[i] + 1, m); // 每一行算一次
    }
    printf("%lld\n", ans);
    return 0;
}
/**
2 2
0 1
1 1 
子矩形数量是5
**/
```



## 树状数组

Tips: lowbit(x) => (x & (-x)) 的含义：当 *x* 为 0 时，结果为 0。当 *x* 为奇数时，结果为 1。当 *x* 为偶

数时，结果为 *x* 中 2 的最大次方的因子。

### 区间修改，区间求和

​	

```cpp
namespace Fenwick {
    int c0[maxn], c1[maxn], n;
    
    inline int lowbit(int x) { return x & (-x); }
    
    void add(int k, int v) {
      int i = k * v;
      while (k <= n) {
        c0[k] += v, c1[k] += i;
        k += lowbit(k);
      }
    }
    int sum(int k) {
      int ret = 0;
      int i = k + 1;
      while (k) {
        ret += i * c0[k] - c1[k];
        k -= lowbit(k);
      }
      return ret;
    }
    
    void modify(int l, int r, int v) {
      add(l, v), add(r + 1, -v);  // 将区间加差分为两个前缀加
    }
    
    long long query(int l, int r) {
      return sum(r) - sum(l - 1);
    }
}
```

### 三维前缀和

树状数组维护三维前缀和
$$
\sum_{i=1}^{n}\sum_{j=1}^i\sum_{k=1}^jd_k=\frac{1}{2}[(n^2+3n+2)\sum_{i=1}^nd_i-(2n+3)\sum_{i=1}^ni·d_i+\sum_{i=1}^ni^2·d_i]
$$
由此也成功转化成三个一阶前缀和问题，如果继续推下去，会发现 $n$ 个树状数组就可以解决 $n$ 阶前缀和问题

```cpp
namespace Fenwick {
    const int maxn = 1100;
    int c0[maxn], c1[maxn], c2[maxn];
    void add(int k, int v)
    {
        int i = k * v, ii = 1ll * k * k * v;
        while (k < maxn)
        {
            c0[k] += v;
            c1[k] += i;
            c2[k] += ii;
            k += k & -k;
        }
    }
    int sum(int k)
    {
        int ans = 0;
        int k1 = 1ll * k * k + 3 * k + 2, k2 = 2 * k + 3;
        while (k)
        {
            ans += k1 * c0[k] - k2 * c1[k] + c2[k];
            k -= k & -k;
        }
        return ans >> 1;
    }
    void modify(int l, int r, int v)
    {
        add(l, v);
        add(r + 1, -v);
    }
}
```

### 二维树状数组（矩阵求和与修改）

```cpp
namespace Fenwick_2D {
    int c0[maxn][maxn], c1[maxn][maxn], c2[maxn][maxn], c3[maxn][maxn];
    int n, m;
    inline int lowbit(int x) {
        return x & (-x);
    }
    void add(int x, int y, int v) {
        int i = x;
        while (i <= n) {
            int j = y;
            while (j <= m) {
                c0[i][j] += v;
                c1[i][j] += v * x;
                c2[i][j] += v * y;
                c3[i][j] += v * x * y;
                j += lowbit(j);
            }
            i += lowbit(i);
        }
    }
    int sum(int x, int y) {
        int ret = 0, i = x;
        while (i) {
            int j = y;
            while (j) {
                ret += c0[i][j] * (x + 1) * (y + 1);
                ret -= c1[i][j] * (y + 1);
                ret -= c2[i][j] * (x + 1);
                ret += c3[i][j];
                j -= lowbit(j);
            }
            i -= lowbit(i);
        }
        return ret;
    }
        /* 在矩形 (x0, y0),(x1, y1) 上加上 v */
    void change(int x0, int y0, int x1, int y1, int v) {
        add(x0, y0, v);
        add(x1 + 1, y0, -v);
        add(x0, y1 + 1, -v);
        add(x1 + 1, y1 + 1, v);
    }
    /* 查询矩形 (x0, y0),(x1, y1) 所有元素的和 */
    int query(int x0, int y0, int x1, int y1) {
        return sum(x1, y1) - sum(x0 - 1, y1) - sum(x1, y0 - 1) + sum(x0 - 1, y0 - 1);
    }
}using namespace Fenwick_2D;
```

### 三维树状数组

```cpp
inline int lowbit(int x) { return x & -x; }
void update(int x, int y, int z, int d) {
    for (int i = x; i <= n; i += lowbit(i))
        for (int j = y; j <= n; j += lowbit(j))
            for (int k = z; k <= n; k += lowbit(k))
                c[i][j][k] += d;
}
long long query(int x, int y, int z) {
    long long ret = 0;
    for (int i = x; i > 0; i -= lowbit(i))
        for (int j = y; j > 0; j -= lowbit(j))
            for (int k = z; k > 0; k -= lowbit(k))
                ret += c[i][j][k];
    return ret;
}
long long solve(int x0, int y0, int z0, int x1, int y1, int z1) {
    return    query(x1, y1, z1)
            - query(x1, y1, z0 - 1)
            - query(x1, y0 - 1, z1)
            - query(x0 - 1, y1, z1)
            + query(x1, y0 - 1, z0 - 1)
            + query(x0 - 1, y1, z0 - 1)
            + query(x0 - 1, y0 - 1, z1)
            - query(x0 - 1, y0 - 1, z0 - 1);
```



## 线段树

### 不降子序列

线段树维护以某点为开头的最长不下降子序列，使用下面calc函数能够计算线段树**u维护的区间中**，以$x$ 为开头最长不下降子序列的个数。calc需要维护区间最值。

```cpp
template<typename T>
int calc(int u,T x)
{
    if(t[u].l==t[u].r) 
    	return t[u].v>x?1:0;
    if(t[u<<1].v<=x) 
    	return calc(u<<1|1,x);
    return t[u].cnt-t[u<<1].cnt+calc(u<<1,x);
}
```

### 维护矩阵

维护三个长度为 $\mathrm{n}$ 的序列 $\mathrm{A}, \mathrm{B}, \mathrm{C}$ ，支持以下 7 种操作：$\mathrm{n}, \mathrm{m} \leq 2.5 \times 10^5, 0 \leq \mathrm{A}_{\mathrm{i}}, \mathrm{B}_{\mathrm{i}}, \mathrm{C}_{\mathrm{i}}<998244353$

1. $l, r$ : 对 $[l, \mathrm{r}], \mathrm{A}_{\mathrm{i}} \leftarrow \mathrm{A}_{\mathrm{i}}+\mathrm{B}_{\mathrm{i}}$;
2. $l, r$ : 对 $[l, \mathrm{r}],  \mathrm{B}_{\mathrm{i}} \leftarrow \mathrm{B}_{\mathrm{i}}+\mathrm{C}_{\mathrm{i}}$;
3. $l, r$ : 对 $[l, \mathrm{r}], \mathrm{C}_{\mathrm{i}} \leftarrow \mathrm{C}_{\mathrm{i}}+\mathrm{A}_{\mathrm{i}}$ ；
4. $l, r,v$ : 对 $[l, \mathrm{r}],  \mathrm{A}_{\mathrm{i}} \leftarrow \mathrm{A}_{\mathrm{i}}+\mathrm{v}$;
5. $l, r,v$ : 对 $[l, \mathrm{r}],   \mathrm{B}_{\mathrm{i}} \leftarrow \mathrm{B}_{\mathrm{i}} \cdot \mathrm{v}$ ；
6. $l, r,v$ : 对 $[l, \mathrm{r}],   \mathrm{C}_{\mathrm{i}} \leftarrow \mathrm{v}$;
7. $l,r$ : 求 $\sum_{\mathrm{i}=l}^{\mathrm{r}} \mathrm{A}_{\mathrm{i}}, \sum_{\mathrm{i}=l}^{\mathrm{r}} \mathrm{B}_{\mathrm{i}}, \sum_{\mathrm{i}=l}^{\mathrm{r}} \mathrm{C}_{\mathrm{i}}$ ，在模 998244353 意义下。 

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 250010;

const ll mod = 998244353;
struct dat {
    int n, m;
    ll a[5][5];
    dat() {}
    dat(int _n, int _m) {
        n = _n;
        m = _m;
        memset(a, 0, sizeof a);
    }
    friend dat operator +(const dat &X, const dat &Y) {
        //assert(X.n==Y.n);
        //assert(X.m==Y.m);
        dat ret(X.n, X.m);

        for (int i = 1; i <= X.n; i++)
            for (int j = 1; j <= X.m; j++)
                ret.a[i][j] = (X.a[i][j] + Y.a[i][j]) % mod;

        return ret;
    }
    friend dat operator *(const dat &X, const dat &Y) {
        dat ret(X.n, Y.m);
        assert(X.m == Y.n);
        for (int i = 1; i <= X.n; i++)
            for (int j = 1; j <= Y.m; j++)
                for (int k = 1; k <= X.m; k++)
                    ret.a[i][j] = (ret.a[i][j] + X.a[i][k] * Y.a[k][j]) % mod;
        return ret;
    }
};
struct node {
    int l, r;
    dat v, tag;
} t[N << 2];

int n, m;
dat num[N];
dat base1, base2, base3, base4, base5, base6;
dat base;
void build(int u, int l, int r) {
    t[u].l = l, t[u].r = r;
    if (l == r) {
        t[u].v = num[l];
        t[u].tag = base;
        return;
    }
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
    t[u].v = t[u << 1].v + t[u << 1 | 1].v;
    t[u].tag = base;
}
void put(int u, dat &v) {
    t[u].v = t[u].v * v;
    t[u].tag = t[u].tag * v;
}
void pushdown(int u) {
    put(u << 1, t[u].tag);
    put(u << 1 | 1, t[u].tag);
    t[u].tag = base;
}
void modify(int u, int l, int r, dat v) {
    if (l <= t[u].l && t[u].r <= r) {
        t[u].v = t[u].v * v;
        t[u].tag = t[u].tag * v;
        return;
    }
    pushdown(u);
    int mid = t[u].l + t[u].r >> 1;
    if (l <= mid) modify(u << 1, l, r, v);
    if (r > mid) modify(u << 1 | 1, l, r, v);
    t[u].v = t[u << 1].v + t[u << 1 | 1].v;
}
dat query(int u, int l, int r) {
    if (l <= t[u].l && t[u].r <= r)
        return t[u].v;
    pushdown(u);
    int mid = t[u].l + t[u].r >> 1;
    dat v(1, 4);
    if (l <= mid) v = v + query(u << 1, l, r);
    if (r > mid) v = v + query(u << 1 | 1, l, r);
    return v;
}

void init() {
    base = dat(4, 4);
    for (int i = 1; i <= 4; i++)
        base.a[i][i] = 1;

    /*
    base1:| base2:| base3:
    1 0 0 | 1 0 0 | 1 0 1
    1 1 0 | 0 1 0 | 0 1 0
    0 0 1 | 0 1 1 | 0 0 1
    */
    base1 = base;
    base1.a[2][1] = 1;
    base2 = base;
    base2.a[3][2] = 1;
    base3 = base;
    base3.a[1][3] = 1;
    /*
    base4:  | base5:  | base6:
    1 0 0 0 | 1 0 0 0 | 1 0 0 0
    0 1 0 0 | 0 v 0 0 | 0 1 0 0
    0 0 1 0 | 0 0 1 0 | 0 0 0 0
    v 0 0 1 | 0 0 0 1 | 0 0 v 1
    */
    base4 = base; // [4][1]=v
    base5 = base; // [2][2]=v;
    // [4][3]=v;
    base6 = base;
    base6.a[3][3] = 0;
}


int main() {
    init();
    cin >> n;
    for (int i = 1; i <= n; i++) {
        num[i] = dat(1, 4);
        cin >> num[i].a[1][1] >> num[i].a[1][2] >> num[i].a[1][3];
        num[i].a[1][4] = 1;
    }
    build(1, 1, n);
    cin >> m;

    while (m--) {
        int op, l, r, v;
        cin >> op >> l >> r;
        if (op == 1)
            modify(1, l, r, base1);
        else if (op == 2)
            modify(1, l, r, base2);
        else if (op == 3)
            modify(1, l, r, base3);
        else if (op == 4) {
            cin >> v;
            base4.a[4][1] = v;
            modify(1, l, r, base4);
        } else if (op == 5) {
            cin >> v;
            base5.a[2][2] = v;
            modify(1, l, r, base5);
        } else if (op == 6) {
            cin >> v;
            base6.a[4][3] = v;
            modify(1, l, r, base6);
        } else {
            dat ret = query(1, l, r);
            cout << ret.a[1][1] << ' ' << ret.a[1][2] << ' ' << ret.a[1][3] << '\n';
        }
    }

    return 0;
}
```

### 区间NAND

 - 询问$[l,r]$区间与非的值即$a_l \text{NAND} a_{l+1} \text{NAND}\dots \text{NAND} a_r$
 - 单线修改$p,x$即$a_p=x$

区间与非**没有结合律**，这样的信息线段树不能直接维护，不过位运算具有独立性，我们可以一位一位去考虑。

考虑用线段树每个节点维护$\text{L}[0/1],\text{R}[0/1]$

$\text{L}[0]$表示刚开是$0$，然后从左向右经过**此区间**是最终的数（此节点维护的区间）

$\text{L}[1]$表示刚开是$1$，然后从左向右经过**此区间**是最终的数

$\text{R}[0]$表示刚开是$0$，然后从右向左经过**此区间**是最终的数

$\text{R}[1]$表示刚开是$1$，然后从右向左经过**此区间**是最终的数

然后只需要维护32棵线段树（按位），就可以区间询问了。而且区间是从左向右，有的区间是从右向左的答案也不一样！

```cpp
struct Segment
{
    struct node
    {
        int l,r;
        bool L[2],R[2];
    }tree[N<<2];
    void pushup(int u)
    {
        tree[u].L[0]=tree[u<<1|1].L[tree[u<<1].L[0]];
        tree[u].L[1]=tree[u<<1|1].L[tree[u<<1].L[1]];
        tree[u].R[0]=tree[u<<1].R[tree[u<<1|1].R[0]];
        tree[u].R[1]=tree[u<<1].R[tree[u<<1|1].R[1]];
    }
    void build(int u,int l,int r,int k)
    {
        tree[u].l=l,tree[u].r=r;
        if(l==r) 
        {
            tree[u].L[0]=tree[u].R[0]=1;
            tree[u].L[1]=tree[u].R[1]=!(a[id[l]]>>k&1);
            return;
        }
        int mid=l+r>>1;
        build(u<<1,l,mid,k);build(u<<1|1,mid+1,r,k);
        pushup(u);
    }
    void modify(int u,int pos,bool x)
    {
        if(tree[u].l==tree[u].r)
        {
            tree[u].L[0]=tree[u].R[0]=1;
            tree[u].L[1]=tree[u].R[1]=(!x);
            return;
        }
        int mid=tree[u].l+tree[u].r>>1;
        if(pos<=mid) 
            modify(u<<1,pos,x);
        else
            modify(u<<1|1,pos,x);
        pushup(u);
    }
    bool queryL(int u,int l,int r,bool c)
    {
        if(l<=tree[u].l&&tree[u].r<=r) return tree[u].L[c];
        int mid=tree[u].l+tree[u].r>>1;
        if(r<=mid)
            return queryL(u<<1,l,r,c);
        else if(l>mid) 
            return queryL(u<<1|1,l,r,c);
        else 
            return queryL(u<<1|1,l,r,queryL(u<<1,l,r,c));
        
    }
    bool queryR(int u,int l,int r,bool c)
    {
        if(l<=tree[u].l&&tree[u].r<=r) return tree[u].R[c];
        int mid=tree[u].l+tree[u].r>>1;
        if(r<=mid)
            return queryR(u<<1,l,r,c);
        else if(l>mid) 
            return queryR(u<<1|1,l,r,c);
        else 
            return queryR(u<<1,l,r,queryR(u<<1|1,l,r,c));
    }
}T[33];
```



### 主席树

可持久化线段树的主要思想：保存每次插入操作的历史版本，实际上是在动态开点线段树的基础上，

通过复用某些未修改的节点，创建 $n$ 棵线段树。每进行一次修改时，产生新的节点数 = 树的高度，是

$O(n \log n)$ 级别的。

```cpp
struct node
{
    int l,r;
    ll v;
}t[N*40];
int rt[N],cnt;
void ins(int &u,int o,int l,int r,int pos)
{
    u=++cnt;
    t[u]=t[o];
    t[u].v+=pos;
    if(l==r) return;
    int mid=l+r>>1;
    if(pos<=mid) 
        ins(t[u].l,t[o].l,l,mid,pos);
    else
        ins(t[u].r,t[o].r,mid+1,r,pos);
}
ll query(int u,int l,int r,int L,int R)
{
    if(!u) return 0ll;
    if(L<=l&&r<=R) return t[u].v;
    int mid=l+r>>1;
    ll v=0;
    if(L<=mid)   
        v+=query(t[u].l,l,mid,L,R);
    if(R>mid)
        v+=query(t[u].r,mid+1,r,L,R);
    return v;
}

```

###  动态开点权值线段树

有的时候，线段树需要维护的区间很大很大，但是实际用到的节点很少；那么干脆就不要开这么多的

节点，用到的时候再向内存要。

例如要建立一个权值线段树，但是在线操作不让离散化，值域又是 *∞* 级别的。即使这个区间的范围

很大，但是如果询问 *q* 比较少的话，我们只需要*q* log *inf* 个节点，就可以办到。

由于是动态开点的，左右子节点的下标代数关系就不再成立，因此节点中需要记录当前节点的左子树

和右子树根节点位置。

```cpp
namespace DynamicSegTree {
    struct Node {
        int l, r, v;
    }t[maxn*40];
    int cnt;
    // 修改操作，若 u 不存在，则首先动态开点；否则直接更新
    void update(int &u, int l, int r, int pos, int val) {
        if(!u) u = ++cnt;
        // ....
    }
    // 查询操作区间 [L, R] ，若 u 不存在直接返回空值（可能是 0 或者反向最值）
    int query(int u, int l, int r, int L, int R) {
        if(!u) 
            return 0;
        // .....
    }

}using namespace DynamicSegTree;

```



### 线段树合并

```cpp
int merge(int x,int y,int l,int r)
{
    if(!x||!y) return x+y;
    int mid=l+r>>1;
    if(l==r)
    {
        t[x].val+=t[y].val;
        return x;
    }
    t[x].l=merge(t[x].l,t[y].l,l,mid);
    t[x].r=merge(t[x].r,t[y].r,mid+1,r);
    t[x].val=max(t[t[x].l].val,t[t[x].r].val);
    return x;
}

```

### Segment Tree Beats!

区间最值操作往往采用以下办法 

线段树维护：

 - 区间最大值$\text{mx}$  
 - 区间严格次大值$\text {smx}$  
 - 区间和$\text{sum}$ 
 - 区间最大值个数$\text{cnt}$  
 - 区间最值懒标记$\text{lazy}$

实现区间最小值操作，考虑u节点维护的区间，进行如下处理

 - 当$\text{mx}\leq x$，显然这次修改不会对这个节点维护的区间产生影响，直接退出。
 - 当$\text{smx}<x<\text{mx}$，显然这次修改只会影响到这个区间所有的最大值，由此直接根据最大值个数更新区间和并且更新区间最大值并打上懒标记然后退出即可。
 - 当$\text{x}\leq \text{smx}$，无法直接更新于是递归左右子树。

```cpp
struct node
{
    int l,r;// 最大值 次大值 区间和
    ll maxv,secmaxv,sum;
    int cnt;
    ll tag;
}t[N<<2];
int n,m;
ll a[N];
void pushup(int u)
{
    t[u].sum=t[u<<1].sum+t[u<<1|1].sum;
    if(t[u<<1].maxv>t[u<<1|1].maxv)
    {
        t[u].maxv=t[u<<1].maxv;
        t[u].secmaxv=max(t[u<<1].secmaxv,t[u<<1|1].maxv);
        t[u].cnt=t[u<<1].cnt;
    }
    else if(t[u<<1].maxv<t[u<<1|1].maxv)
    {
        t[u].maxv=t[u<<1|1].maxv;
        t[u].secmaxv=max(t[u<<1|1].secmaxv,t[u<<1].maxv);
        t[u].cnt=t[u<<1|1].cnt;
    }
    else 
    {
        t[u].maxv=t[u<<1|1].maxv;
        t[u].secmaxv=max(t[u<<1].secmaxv,t[u<<1|1].secmaxv);
        t[u].cnt=t[u<<1].cnt+t[u<<1|1].cnt;
    }
}
void put(int u,ll x)
{
    if(t[u].maxv<=x) return; 
    t[u].sum+=(x-t[u].maxv)*t[u].cnt;
    t[u].maxv=t[u].tag=x;
}
void pushdown(int u)
{
    if(t[u].tag==-1) return;
    put(u<<1,t[u].tag),put(u<<1|1,t[u].tag);
    t[u].tag=-1;
}
void build(int u,int l,int r)
{
    t[u]={l,r,0,-1,0,0,-1};
    if(l==r) 
    {
        t[u].maxv=t[u].sum=a[l];
        t[u].cnt=1;
        return;
    }
    int mid=l+r>>1;
    build(u<<1,l,mid),build(u<<1|1,mid+1,r);
    pushup(u);
}
void modify(int u,int l,int r,ll x)  // 区间[l,r] a[i]=min(a[i],x)
{
    if(x>=t[u].maxv) return;
    if(t[u].l>=l&&t[u].r<=r&&t[u].secmaxv<x)
    {
        put(u,x);
        return;
    }
    pushdown(u);
    int mid=t[u].l+t[u].r>>1;
    if(l<=mid) modify(u<<1,l,r,x);
    if(r>mid) modify(u<<1|1,l,r,x);
    pushup(u);
    
}
ll qmax(int u,int l,int r)
{
    if(t[u].l>=l&&t[u].r<=r) return t[u].maxv;
    int mid=t[u].r+t[u].l>>1;
    pushdown(u);
    ll v=-1;
    if(l<=mid) v=max(v,qmax(u<<1,l,r));
    if(r>mid) v=max(v,qmax(u<<1|1,l,r));
    pushup(u);
    return v;
}
ll qsum(int u,int l,int r)
{
    if(t[u].l>=l&&t[u].r<=r) return t[u].sum;
    int mid=t[u].r+t[u].l>>1;
    pushdown(u);
    ll v=0;
    if(l<=mid) v+=qsum(u<<1,l,r);
    if(r>mid) v+=qsum(u<<1|1,l,r);
    pushup(u);
    return v;
}
```

> 维护一个长度为 n 的序列，支持 m 次操作，操作包括区间按位或一个数，区间按位与一个数，以及查询区间最大值。

线段树每个节点上维护区间与、区间或和区间最大值。
如果一次操作对区间与的影响和对区间或的影响相同，那么就说明对这整个区间的影响都是相同的，就是加上或减去同一个值，直接打标记即可，否则递归下去处理。

## 树套树

### 树状数组套权值线段树

二维数颜色

```cpp
#include<bits/stdc++.h>
using namespace std;
template <class T=int> T rd()
{
    T res=0;
    char ch=getchar();
    while(!isdigit(ch)) ch=getchar();
    while( isdigit(ch)) res=(res<<1)+(res<<3)+(ch^48),ch=getchar();
    return res;
}
const int N=100010;
int a[N],n,m,ans[N],last[N];
struct nodeq
{
    int l,L,R,id;
};
vector<nodeq> q[N];
struct node
{
    int l,r,v;
}tree[N*200];
int rt[N],cnt,lim;
void update(int &u,int l,int r,int pos,int v)
{
    if(!u) u=++cnt;
    tree[u].v+=v;
    if(l==r) return;
    int mid=l+r>>1;
    if(pos<=mid) update(tree[u].l,l,mid,pos,v);
    if(pos>mid)  update(tree[u].r,mid+1,r,pos,v);
    //tree[u].v=tree[tree[u].l].v+tree[tree[u].r].v;
}
int query(int u,int l,int r,int L,int R)
{
    if(!u) return 0;
    if(L<=l&&r<=R) return tree[u].v;
    int mid=l+r>>1;
    int v=0;
    if(L<=mid) v+=query(tree[u].l,l,mid,L,R);
    if(R>mid) v+=query(tree[u].r,mid+1,r,L,R);
    return v;
}
/* 树状数组 */
// rt[i] 保存每个单点对应的权值线段树根节点，
int lowbit(int x){return x&-x;}
void add(int k,int pos,int v)
{
    for(;k<=n;k+=lowbit(k)) update(rt[k],0,lim,pos,v);
}
int ask(int k,int L,int R)
{
    int ans=0;
    for(;k;k-=lowbit(k)) ans+=query(rt[k],0,lim,L,R);
    return ans;
}
int main()
{
    n=rd(),m=rd();
    for(int i=1;i<=n;i++) a[i]=rd();
    lim=*max_element(a+1,a+1+n);
    
    for(int i=1;i<=m;i++)
    {
        int x0=rd(),y0=rd(),x1=rd(),y1=rd();
        q[x1].push_back({x0,y0,y1,i});
    }
    for(int i=1;i<=n;i++)
    {
        if(last[a[i]]) add(last[a[i]],a[i],-1);
        add(i,a[i],1);last[a[i]]=i;
        for(auto t:q[i])
            ans[t.id]=ask(i,t.L,t.R)-ask(t.l-1,t.L,t.R);
    }
    for(int i=1;i<=m;i++) printf("%d\n",ans[i]);
    
}

```



## Splay 【模板】普通平衡树

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 110000;
//若要修改一个点的点权，应当先将其 splay 到根，然后修改，最后还要调用 pushup 维护。
//调用完 splay 之后根结点会改变，应该用 splay 的返回值更新根结点。

namespace splay_tree {
    int ch[maxn][2], fa[maxn], stk[maxn], rev[maxn], sz[maxn], key[maxn], tot;
    int rt, cnt[maxn];
    void init() {
        tot = rt = 0;
    }
    int newnode(int val) {
        int x = ++tot;
        ch[x][0] = ch[x][1] = fa[x] = rev[x] = 0;
        sz[x] = cnt[x] = 1;
        key[x] = val;
        return x;
    }
    void clear(int x) {
        ch[x][0] = ch[x][1] = fa[x] = key[x] = sz[x] = cnt[x] = rev[x] = 0;
    }
    inline bool son(int x) {// x是fa的哪个儿子 0/1 左/右
        return ch[fa[x]][1] == x;
    }
    inline void pushup(int x) {
        sz[x] = sz[ch[x][0]] + sz[ch[x][1]] + cnt[x];
    }
    inline void pushdown(int x) {
        if (rev[x]) {
            rev[x] = 0;
            swap(ch[x][0], ch[x][1]);
            rev[ch[x][0]] ^= 1;
            rev[ch[x][1]] ^= 1; 
        }
    }
    void rotate(int x) { //左旋和右旋
        int y = fa[x], z = fa[y], c = son(x);
        if (fa[y])
            ch[z][son(y)] = x;
        fa[x] = z;

        ch[y][c] = ch[x][!c];fa[ch[y][c]] = y;
        ch[x][!c] = y;fa[y] = x;
        pushup(y);
    }
    void ascend(int x) { // 将 x 反转到根
        for (int y = fa[x]; y; rotate(x), y = fa[x]) 
            if (fa[y]) son(x) ^ son(y) ? rotate(x) : rotate(y);
        pushup(x);
        rt = x;
    }
    int splay(int x) {   // 没有 pushdown 操作时，可以直接用 ascend 替换 splay
        int top = 0;     // 每访问一个节点 x 后都要强制将其旋转到根节点
        for (int i = x; i; i = fa[i])
            stk[++top] = i;
        while (top)
            pushdown(stk[top--]);
        ascend(x);
        return x;
    }
    int splay(int x, int k) { //将以 x 为根的子树中的第 k 个结点旋转到根结点
        while (pushdown(x), k != sz[ch[x][0]] + 1) {
            if (k <= sz[ch[x][0]])
                x = ch[x][0];
            else
                k -= sz[ch[x][0]] + 1, x = ch[x][1];
        }
        if (x) ascend(x);
        return x;
    }
    void ins(int k) { // 插入 k 数
        if(!rt) {
            rt = newnode(k);
            pushup(rt);
            return;
        }
        int cur = rt, f = 0;
        while (1) {
            if (key[cur] == k) {
                cnt[cur] ++;
                pushup(cur);
                pushup(f);
                splay(cur);
                break;
            }
            f = cur;
            cur = ch[cur][key[cur] < k];
            if(!cur) {
                int x = newnode(k);
                fa[x] = f;
                ch[f][key[f] < k] = x;
                pushup(x);
                pushup(f);
                splay(x);
                break;
            }
        }
    }
    int rk(int k) { // k的排名 排名定义为比当前数小的数的个数 +1
        int ret = 0, cur = rt;
        while (1) {
            if (k < key[cur]) 
                cur = ch[cur][0];
            else {
                ret += sz[ch[cur][0]];
                if (k == key[cur]) {
                    splay(cur);
                    return ret + 1;
                }
                ret += cnt[cur];
                cur = ch[cur][1];
            }
        }
    }
    int kth(int k) { // 第k大
        int cur = rt;
        while (1) {
            if (ch[cur][0] && k <= sz[ch[cur][0]]) 
                cur = ch[cur][0];
            else {
                k -= cnt[cur] + sz[ch[cur][0]];
                if (k <= 0) {
                  splay(cur);
                  return key[cur];
                }
                cur = ch[cur][1];
            }
        }
    }
    int pre() { // 根节点前驱
        int cur = ch[rt][0];
        if (!cur) return cur;
        while (ch[cur][1]) cur = ch[cur][1];
        splay(cur);
        return cur;
    }
    int nxt() { // 根节点后继
        int cur = ch[rt][1];
        if (!cur) return cur;
        while (ch[cur][0]) cur = ch[cur][0];
        splay(cur);
        return cur;
    }
    void del(int k) {  // 删除 x 数(若有多个相同的数，因只删除一个)
        rk(k);
        if (cnt[rt] > 1) {
            cnt[rt]--;
            pushup(rt);
            return;
        }
        if (!ch[rt][0] && !ch[rt][1]) {
            clear(rt);
            rt = 0;
            return;
        }
        if (!ch[rt][0]) {
            int cur = rt;
            rt = ch[rt][1];
            fa[rt] = 0;
            clear(cur);
            return;
        }
        if (!ch[rt][1]) {
            int cur = rt;
            rt = ch[rt][0];
            fa[rt] = 0;
            clear(cur);
            return;
        }
        int cur = rt, x = pre();
        fa[ch[cur][1]] = x;
        ch[x][1] = ch[cur][1];
        clear(cur);
        pushup(rt);
    }
     template<typename ...T> int merge(int x, int y, T... args) {
        if constexpr (sizeof...(args) == 0) {
            if (x == 0) return y; //swap(x, y);
            x = splay(x, sz[x]);
            ch[x][1] = y; fa[y] = x;
            pushup(x);
            return x;
        }
        else {
            return merge(merge(x, y), args...);
        } 
    }
    auto split(int x, int pos) { //分成两个区间 [1, pos - 1] 和 [pos, n]
        if (pos == sz[x] + 1)
            return make_pair(x, 0);
        x = splay(x, pos);    // 找到x子树中的第pos个数
        int y = ch[x][0];
        fa[y] = ch[x][0] = 0; // 断掉边
        pushup(x);
        return make_pair(y, x);
    }
    auto extract(int x, int L, int R) { // 将根节点是x的splay 区间[L,R]单独搞出来
        auto [left, y] = split(x, L);
        auto [mid, right] = split(y, R - L + 2);
        return make_tuple(left, mid, right);
    }
    void traverse(int x) { //中序遍历
        if (x != 0) {
            pushdown(x);
            traverse(ch[x][0]);
            printf("%d ", key[x]);
            //printf("%d (left: %d, right: %d) sz(%d) key(%d)\n", x, ch[x][0], ch[x][1], sz[x],key[x]);
            traverse(ch[x][1]);
        }
    }
}
using namespace splay_tree;


int main() {

    init();
    int n, opt, x;
    for (scanf("%d", &n); n; --n) {
        scanf("%d%d", &opt, &x);
        if (opt == 1)
            ins(x);
        else if (opt == 2)
            del(x);
        else if (opt == 3)
            printf("%d\n", rk(x));
        else if (opt == 4)
            printf("%d\n", kth(x));
        else if (opt == 5)
            ins(x), printf("%d\n", key[pre()]), del(x);
        else
            ins(x), printf("%d\n", key[nxt()]), del(x);
    }
    return 0;
}
```

## LCT

### 模板

```cpp
//若要修改一个点的点权，应当先将其 splay 到根，然后修改，最后还要调用 pushup 维护。
namespace lct {
    int ch[maxn][2], fa[maxn], stk[maxn], rev[maxn];
    int sz[maxn];
    void init() { //初始化 link-cut-tree
        memset(ch, 0, sizeof(ch));
        memset(fa, 0, sizeof(fa));
        memset(rev, 0, sizeof(rev));
        memset(sz, 0, sizeof(sz));
    }
    inline bool son(int x) {
        return ch[fa[x]][1] == x;
    }
    inline bool isroot(int x) {
        return ch[fa[x]][1] != x && ch[fa[x]][0] != x;
    }
    inline void reverse(int x) { //给结点 x 打上反转标记
        swap(ch[x][1], ch[x][0]);
        rev[x] ^= 1;
    }
    inline void pushup(int x) {
        sz[x] = sz[ch[x][0]] + sz[ch[x][1]] + 1;
    }
    inline void pushdown(int x) {
        if (rev[x]) {
            reverse(ch[x][0]);
            reverse(ch[x][1]);
            rev[x] = 0;
        }
    }
    void rotate(int x) {
        int y = fa[x], z = fa[y], c = son(x);
    
        if (!isroot(y))
            ch[z][son(y)] = x;
    
        fa[x] = z;
        ch[y][c] = ch[x][!c];
        fa[ch[y][c]] = y;
        ch[x][!c] = y;
        fa[y] = x;
        pushup(y);
    }
    void splay(int x) {
        int top = 0;
        stk[++top] = x;
    
        for (int i = x; !isroot(i); i = fa[i])
            stk[++top] = fa[i];
    
        while (top)
            pushdown(stk[top--]);
    
        for (int y = fa[x]; !isroot(x); rotate(x), y = fa[x])
            if (!isroot(y))
                son(x) ^ son(y) ? rotate(x) : rotate(y);
    
        pushup(x);
    }
    void access(int x) { // 建立从根到 x 的路径
        for (int y = 0; x; y = x, x = fa[x]) {
            splay(x);
            ch[x][1] = y;
            pushup(x);
        }
    }
    void makeroot(int x) { //将 x 变为树的新的根结点
        access(x);
        splay(x);
        reverse(x);
    }
    int findroot(int x) { //返回 x 所在树的根结点
        access(x);
        splay(x);
    
        while (ch[x][0])
            pushdown(x), x = ch[x][0];
    
        splay(x);
        return x;
    }
    void split(int x, int y) { //提取出来 y 到 x 之间的路径，并将 y 作为根结点
        makeroot(x);
        access(y);
        splay(y);
    }
    void cut(int x, int y) { //切断 x 与 y 相连的边
        makeroot(x);         //将 x 置为整棵树的根
    
        if (findroot(y) == x && fa[y] == x && !ch[y][0]) {
            fa[y] = ch[x][1] = 0;
            pushup(x);
        }
    }
    void link(int x, int y) { //连接 x 与 y
        makeroot(x);
    
        if (findroot(y) != x)
            fa[x] = y;
    }
}
```

### LCT 动态维护直径

> 一开始有 n 个点的无边无向图，接下来有 q 次操作，每次操作分为以下两种：
>
> - `1 u v`：将 u 和 v 连边，保证 u 和 v 不连通。
> - `2 u`：询问 u 能到达的最远的点与 u 的距离。

两颗子树合并后的直径端点只有六种情况。六种情况讨论一下即可维护合并后树的直径。

```cpp
using namespace lct;

const int N = 300005;

int dis(int x, int y) {
    split(x, y);
    return sz[y] - 1;
}
struct dia {
    int u, v, w;
    bool operator<(const dia &o)const {
        return w < o.w;
    }
    dia operator +(const dia &o)const {
        dia ret = max(*this, o);// 原来树的直径
        // 两条直径端点组合构成新的直径
        ret = max(ret, {u, o.u, dis(u, o.u)});
        ret = max(ret, {u, o.v, dis(u, o.v)});
        ret = max(ret, {v, o.u, dis(v, o.u)});
        ret = max(ret, {v, o.v, dis(v, o.v)});
        return ret;
    }
} d[N];
int dsu[N];
int find(int x) {
    return x == dsu[x] ? x : dsu[x] = find(dsu[x]);
}
void merge(int x, int y) {
    link(x, y);
    x = find(x), y = find(y);
    dsu[x] = y;
    d[y] = d[x] + d[y];
}
int n, q;
int type;

int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);
    init();
    cin >> type >> n >> q;

    for (int i = 1; i <= n; i++) dsu[i] = i, sz[i] = 1, d[i] = {i, i, 0};

    int lastans = 0;// 强制在线

    while (q--) {
        int op;
        cin >> op;
        if (op == 1) {
            int u, v;
            cin >> u >> v;
            if (type) u ^= lastans, v ^= lastans;
            merge(u, v);
        } else {
            int x;
            cin >> x;
            if (type) x ^= lastans;
            auto [u, v, w] = d[find(x)];
            lastans = max(dis(x, u), dis(x, v));
            cout << lastans << '\n';
        }
    }
    return 0;
}
```

LCT可以维护森林的树上距离，如果树的形态在询问前可以确定，那么可以使用O1求LCA从而求出树上距离，进而可以离线维护直径。

## 可回滚并查集

- 注意这个不是可持久化并查集

- 查找时不进行路径压缩

- 复杂度靠按秩合并解决

那观察我们的合并操作，我们每次只修改了两个数的值，所以用一个栈记录修改的值。

```cpp
namespace uf {
    int fa[maxn], sz[maxn];
    int undo[maxn], top;
    void init() { memset(fa, -1, sizeof fa); memset(sz, 0, sizeof sz); top = 0; }
    int find(int x) { while (fa[x] != -1) x = fa[x]; return x; }
    bool join(int x, int y) {
        x = find(x); y = find(y);
        if (x == y) return false;
        if (sz[x] > sz[y]) swap(x, y);
        undo[top++] = x;
        fa[x] = y;
        sz[y] += sz[x] + 1;
        return true;
    }
    inline int checkpoint() { return top; }
    void rewind(int t) {
        while (top > t) {
            int x = undo[--top];
            sz[fa[x]] -= sz[x] + 1;
            fa[x] = -1;
        }
    }
}
```

## 树链剖分

**问题场景** 链上求和，链上求最值，链上修改，子树修改，子树求和。如：修改和查询点 *x* 到 *y* 的路

径的信息；修改和查询以 *x* 为根的子树的信息。

```cpp
/**
 * 第一次 DFS,需要：
 * 1. 标记每个结点的深度 dep[]
 * 2. 标记每个结点的父亲 fa[]
 * 3. 标记每个非叶子结点的子树大小 sz[]
 * 4. 标记每个非叶子结点的重儿子编号 son[]
**/
int fa[N], dep[N], sz[N], son[N];
void dfs_calc(int u, int p) {
    fa[u] = p, dep[u] = dep[p] + 1, sz[u] = 1;
    for (int i = h[u]; i != -1; i = ne[i])
        if (e[i] != fa[u]) {
            dfs_calc(e[i], u);
            sz[u] += sz[e[i]];
            if (sz[e[i]] > sz[son[u]])
                son[u] = e[i];
        }
}
/**
 * 第二次 DFS， 需要：
 * 1. 标记每个点的新编号/DFS 序：dfn[u]
 * 2. 根据新编号将值赋到数组中
 * 3. 处理每个点所在链的顶端 top[u]
 * 4. 先处理重儿子，然后递归处理轻儿子
**/

int timestamp, dfn[N], top[N], rev[N];
void dfs_decomposition(int u, int t) {
    top[u] = t, dfn[u] = ++timestamp;
    rev[timestamp] = u;     
    // 先处理重儿子
    if (son[u]) dfs_decomposition(son[u], t);     
    // 处理轻儿子
    for (int i = h[u]; i != -1; i = ne[i])  {
        int v = e[i];
        if (v == fa[u] || v == son[u])
            dfs_decomposition(v, v);    // 轻儿子单独成新链
    }
}
/**
 * 完成后可以用 rev[] 建立线段树，然后下面是查询和修改操作
 * 修改和查询 x 到 y 的路径，直接调用就可以；如果要处理以 x 为根的子树，
 * 因为我们记录了每个非叶结点的子树大小，并且每个子树的新编号都是连续的，
 * 所以直接线段树区间操作 [dfn[x], dfn[x] + sz[x] - 1] 即可
**/
long long query_path(int x, int y) {
    long long ans = 0;
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]]) 
            swap(x, y);
        ans = ans + query(1, 1, n, dfn[top[x]], dfn[x]);
        x = fa[top[x]];
    }
    if (dep[x] > dep[y]) 
        swap(x, y);
    ans = ans + query(1, 1, n, dfn[x], dfn[y]);
    return ans;
}
/* 更新从 (x, y) 的路径 */
void update_path(int x, int y, long long val) {
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]]) 
            swap(x, y);
        update(1, 1, n, dfn[top[x]], dfn[x], val);
        x = fa[top[x]];
    }
    if (dep[x] > dep[y]) 
        swap(x, y);
    update(1, 1, n, dfn[x], dfn[y], val);
}
```

### 树链剖分维护LCA

```cpp
int lca(int x, int y) {
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]])
        swap(x, y);
        x = fa[top[x]];
    }
    return dep[x] < dep[y] ? x : y;
}
int dis(int x, int y) {
    return dep[x] + dep[y] - 2 * dep[lca(x, y)];
}
```

### dfs序+倍增O(1)维护LCA

```cpp
//===========倍增+O(1) LCA
// P3379 【模板】最近公共祖先（LCA）https://www.luogu.com.cn/problem/P3379
#include<bits/stdc++.h>

using namespace std;
const int N=1000010;

int h[N],e[N<<1],ne[N<<1],idx;
void add(int a,int b){e[idx]=b,ne[idx]=h[a],h[a]=idx++;}
int dfn[N],timstamp;
int n,m,rt;
int dep[N],rev[N],fa[N];
void dfs(int u)
{
    dep[u]=dep[fa[u]]+1;
    dfn[u]=++timstamp;
    rev[timstamp]=u;
    for(int i=h[u];i!=-1;i=ne[i])
    {
        int v=e[i];
        if(v==fa[u]) continue;
        fa[v]=u;
        dfs(v);
    }
}
int inline MIN(int x,int y){return dep[x]<dep[y]?x:y;}

int st[N][21];
int lg[N];
int lca(int u,int v)
{
    if(u==v) return u;
    u=dfn[u],v=dfn[v];
    if(u>v) swap(u,v);
    u++;
    int k=lg[v-u+1];
    return fa[MIN(st[u][k],st[v-(1<<k)+1][k])]; 
}
int main()
{
    ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
    cin>>n>>m>>rt;
    for(int i=1;i<=n;i++) h[i]=-1;
    for(int i=1;i<n;i++)
    {
        int a,b;cin>>a>>b;
        add(a,b),add(b,a);
    }
    dfs(rt);
    for(int i=2;i<=n;i++) lg[i]=lg[i>>1]+1;
    for(int i=1;i<=n;i++) st[i][0]=rev[i];
    for(int k=1;k<=lg[n];k++) 
        for(int i=1;i+(1<<k)-1<=n;i++) 
            st[i][k]=MIN(st[i][k-1],st[i+(1<<k-1)][k-1]);

    while(m--)
    {
        int x,y;cin>>x>>y;
        cout<<lca(x,y)<<'\n';
    }
    return 0;
}
```

## 可持久化并查集

> 给定 n 个集合，第 i 个集合内初始状态下只有一个数，为 i。
>
> 有 m 次操作。操作分为 3 种：
>
> - `1 a b` 合并 a,b 所在集合；
> - `2 k` 回到第 k 次操作（执行三种操作中的任意一种都记为一次操作）之后的状态；
> - `3 a b` 询问 a,b 是否属于同一集合，如果是则输出 1，否则输出 0。

```cpp
#include<bits/stdc++.h>

using namespace std;

using pii=pair<int,int>;
constexpr int N(200005);
int n,m;

struct Array
{
    struct Segment
    {
        int l,r,v;
    }t[N*80];
    int rt[N],cnt;
    void build(int &u,int l,int r,int c)
    {
        t[u=++cnt]={0,0,0};
        if(l==r) 
        {
            if(c==1) t[u].v=l;
            else if(c==2) t[u].v=1;
            return;
        }
        int mid=l+r>>1;
        build(t[u].l,l,mid,c),build(t[u].r,mid+1,r,c);
    }
    void update(int &u,int pre,int l,int r,int pos,int v)
    {
        t[u=++cnt]=t[pre];
        if(l==r) return t[u].v=v,void();
        int mid=l+r>>1;
        if(pos<=mid) 
            update(t[u].l,t[pre].l,l,mid,pos,v);
        else
            update(t[u].r,t[pre].r,mid+1,r,pos,v);
    }
    int query(int u,int l,int r,int pos)
    {
        if(l==r) return t[u].v;
        int mid=l+r>>1;
        if(pos<=mid) 
            return query(t[u].l,l,mid,pos);
        else
            return query(t[u].r,mid+1,r,pos);
    }
    void clear(){cnt=0;}
    int inline get(int u,int pos){
        return query(rt[u],1,n,pos);
    }
    void inline ins(int u,int pos,int v)
    {
        update(rt[u],rt[u],1,n,pos,v);
    }
}sz,fa;
int find(int u,int x)
{
    int f=fa.get(u,x);
    return x==f?x:find(u,f);
}
bool inline merge(int v, int a, int b) {
    a=find(v,a),b=find(v,b);
    if(a==b) return false;
    int sa=sz.get(v,a),sb=sz.get(v,b);
    if (sa>sb) swap(a,b),swap(sa,sb);
    fa.ins(v,a,b);sz.ins(v,b,sa+sb);
    return true;
}
int main()
{
    ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);

    cin>>n>>m;
    fa.build(fa.rt[0],1,n,1);
    sz.build(sz.rt[0],1,n,2);

    int op,x,y;
    for(int i=1;i<=m;i++) 
    {
        cin>>op>>x;
        if(op==1)
        {
            cin>>y;
            fa.rt[i]=fa.rt[i-1];
            sz.rt[i]=sz.rt[i-1];
            merge(i,x,y);
        }
        else if(op==2)
        {
            fa.rt[i]=fa.rt[x];
            sz.rt[i]=sz.rt[x];
        }
        else 
        {
            cin>>y;
            int fx=find(i-1,x),fy=find(i-1,y);
            cout<<int(fx==fy)<<'\n';
            fa.rt[i]=fa.rt[i-1];
            sz.rt[i]=sz.rt[i-1];
        }
    }
    return 0;
}
```

## 点分治

**问题场景**

点分治是大规模处理树上路径问题的工具。大意是找到一个点，递归统计其所有子树的答案，然

后利用容斥原理或其它方式合并答案，最后得到整棵树的答案。

> 点分治的技巧是花费log的代价把任意路径变成**通过当前根节点**的路径，也就是**目前考虑的路径都会穿过当前根节点**

**树重心性质**（加粗的两句话互为充要条件，常用来找重心）

1. **对于一棵树 n 个节点的无根树，找到一个点，使得把树变成以该点为根的有根树时，最大子树的结点数最小。**
2. **对于一个大小为 n 的树，删去重心及与它关联的边后，分裂出的所有子树的大小均不超过 n/2。对于包含至少一个结点的树，它的重心只可能有 1 或 2 个。**
3. 树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个重心，他们的距离和一样。
4. 把两棵树通过一条边相连，新的树的重心在原来两棵树重心的连线上。
5. 一棵树添加或者删除一个叶节点，树的重心最多只移动一条边的位置。
6. 一棵树最多有两个重心，且相邻。

---

**步骤**：

- 找到整棵树的重心点 $rt$，由 $rt$ 向下递归求解。

- 统计以 $rt$ 为根的子树的答案 $ans_{rt}^\prime$，并使用容斥原理、染色法等去除不合法的答案，得到 $rt$ 的最终答案 $ans_{rt}$

- 对 $rt$ 的子树 $ch_i$ 求解，同样先找到以 $ch_i$ 为根的子树的重心 $r^\prime$，然后从重心 $r^\prime$ 向下递归求解，回到步骤 (1).

```cpp
#include <bits/stdc++.h>

using namespace std;
const int N = 10010;
int h[N], e[2 * N], ne[2 * N], w[2 * N], idx;
int n, K;
void add(int a, int b, int c) {
    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;
}
int rt, sz[N];
bool del[N]; // 该点是否被删掉
void dfs_rt(int u, int fa, int tot) {
    sz[u] = 1;
    int mx = 0;
    for (int i = h[u]; i != -1; i = ne[i]) {
        int v = e[i];
        if (v == fa || del[v])
            continue;
        dfs_rt(v, u, tot);
        sz[u] += sz[v];
        mx = max(mx, sz[v]);
    }
    mx = max(mx, tot - sz[u]);
    if (2 * mx <= tot)
        rt = u;
}
void dfs_sz(int u, int fa) {
    sz[u] = 1;
    for (int i = h[u]; i != -1; i = ne[i]) {
        int v = e[i];
        if (v == fa || del[v])
            continue;
        dfs_sz(v, u);
        sz[u] += sz[v];
    }
}
int bit[5000010];
int lowbit(int x) {return x & -x;}
void update(int k, int x) {
    if (!k) return bit[k] += x, void;
    for (; k <= K; k += lowbit(k)) bit[k] += x;
}
int query(int k) {
    if (k < 0) return 0;
    int ret = bit[0];
    for (; k; k -= lowbit(k))ret += bit[k];return ret;
}
int cnt, d[N];
void dfs_dist(int u, int fa, int dist) {
    d[++cnt] = dist;
    for (int i = h[u]; i != -1; i = ne[i]) {
        int v = e[i];
        if (v == fa || del[v]) continue;
        dfs_dist(v, u, dist + w[i]);
    }
}
void dfs_clear(int u, int fa, int dist) {
    update(dist, -1);
    for (int i = h[u]; i != -1; i = ne[i]) {
        int v = e[i];
        if (v == fa || del[v]) ontinue;
        dfs_clear(v, u, dist + w[i]);
    }
}
int work(int u, int tot) {
    int ans = 0;
    dfs_rt(u, 0, tot);
    u = rt;
    dfs_sz(u, 0);
    del[u] = 1;
    update(0, 1); // 根节点距离是0

    for (int i = h[u]; i != -1; i = ne[i]) {
        int v = e[i];
        if (del[v]) continue;
        cnt = 0;
        dfs_dist(v, u, w[i]);
        for (int k = 1; k <= cnt; k++) ans += query(K - d[k]);
        for (int k = 1; k <= cnt; k++) update(d[k], 1);
    }
    dfs_clear(u, 0, 0);
    for (int i = h[u]; i != -1; i = ne[i]) {
        int v = e[i];
        if (del[v])
            continue;
        ans += work(v, sz[v]);
    }
    return ans;
}
int main() {
    memset(h, -1, sizeof h);
    idx = 0;
    memset(del, 0, sizeof del);

    for (int i = 1; i < n; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        ++a, ++b;
        add(a, b, c);
        add(b, a, c);
    }

    cout << work(1, n) << '\n';
}
```

## **启发式合并** (DSU on Tree)

```cpp
// CCPC2020 长春 - E. Strange Memory
int sz[maxn], in[maxn], out[maxn], rev[maxn << 2];

vector<int> G[maxn];

void getsz(int u, int p)
{
    sz[u] = 1;
    in[u] = ++timestamp;
    rev[timestamp] = u;
    for (auto v : G[u]) {
        if (v == p) continue;
        getsz(v, u);
        sz[u] += sz[v];
    }
    out[u] = timestamp;
}

void dsu_on_tree(int u, int p, bool keep)
{
    int mx = -1, heavy = -1;
    // 找到子树的重儿子 可以预处理
    for (auto v : G[u])
        if (v != p && sz[v] > mx)
            mx = sz[v], heavy = v;

    for (auto v : G[u])
        if (v != p && v != heavy) dsu_on_tree(v, u, 0);
        
    if (heavy != -1) dsu_on_tree(heavy, u, 1);
    for (auto v : G[u]) {
        if (v == p || v == heavy)
            continue;
        for (int i = in[v]; i <= out[v]; i++) {
            if (rev[i] == 0)
                continue;
            // 统计轻子节点的贡献
            int bitwise = (a[u] ^ a[rev[i]]);
            for (int j = 0; j < maxlog; j++) {
                int bt = ((rev[i] >> j) & 1);
                ans[j] += tot[bitwise][j][!bt];
            }
        }
        // 把轻子节点加进影响中
        for (int i = in[v]; i <= out[v]; i++) {
            if (rev[i] == 0)
                continue;
            for (int j = 0; j < maxlog; j++) {
                int bt = (rev[i] >> j) & 1;
                tot[a[rev[i]]][j][bt]++;
            }
        }
    }
    // 统计自己的贡献，把自己加进影响中
    for (int j = 0; j < maxlog; j++) {
        int bt = (u >> j) & 1;
        tot[a[u]][j][bt]++;
    }
    // 如果当前节点不是重儿子，则消除影响
    if (!keep) {
        for (int i = in[u]; i <= out[u]; i++) {
            if (rev[i] == 0)
                continue;
            for (int j = 0; j < maxlog; j++) {
                int bt = (rev[i] >> j) & 1;
                tot[a[rev[i]]][j][bt]--;
            }
        }
    }
}
```

## 放弃珂朵莉树

放弃珂朵莉树： (CF1638E，学习自jiangly) 维护同色段，可以直接用线段树，也可以用 `std::map<int, Info>`，其中 key 为段的左端点，左闭右开这样 next 就是右端点，value 为段的信息，这种方式非常好写。每次进行区间染色 $[l,r)$ 的时候，先把 $l,r$ 两点加入map，然后就可以直接循环删除中间的，然后处理修改。

> 给定一个长度为 $n$ 的序列，初始时所有元素的值为 0 ，颜色为 1。你需要实现以下三种操作：
>
> - `Color l r c` ：把 $[l,r]$这段的元素颜色改为 $c$
> - `Add c x`：把所有颜色为 $c$ 的元素值都加 $x$
> - `Query i`：输出元素 $i$ 的值

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;


const int N = 1000010;
int n, m;
// map<key,value>  key  表示区间左端点
//                 next 表示区间右端点 [it, next(it))
map<int, int> s;

map<int, int>::iterator split(int x) {
    auto it = prev(s.upper_bound(x));

    if (it->first == x)
        return it;

    return s.emplace(x, it->second).first;
}
// 区间修改单点查询树状数组
namespace Fenwick{
    ll t[N];
    void add(int k, ll x) { for (; k <= n; k += (k & -k)) t[k] += x;}
    ll sum(int k) { ll v = 0; for (; k; k -= (k & -k)) v += t[k]; return v;}
    void update(int l, int r, ll x) { add(l, x); add(r, -x); }
}using namespace Fenwick;

ll tag[N]; // tag[i]颜色是i的懒标记

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    cin >> n >> m;
    // 初始只有一个区间 [1, n+1) 颜色是 1 维护的每一段区间颜色都是相同的
    s[1] = 1;
    s[n + 1] = 0;

    char op[10];
    while (m--) {
        cin >> op;

        if (*op == 'C') {
            int l, r, c;
            cin >> l >> r >> c;
            r++;// 找到 [l, r + 1) 区间
            map<int, int>::iterator it = split(l);
            map<int, int>::iterator ti = split(r);
            
            // 边打标机边合并(erase)区间 最终得到 [l, r + 1)
            for (; it != ti; it = s.erase(it)) 
                update(it->first, next(it)->first, tag[it->second] - tag[c]);
            
            s[l] = c; 
        } else if (*op == 'A') {
            int c, x;
            cin >> c >> x;
            tag[c] += x;
        } else {
            int i;
            cin >> i;
            map<int, int>::iterator it = split(i);
            cout << sum(i) + tag[it->second] << '\n';
        }
    }

    return 0;
}
```



## pb-ds 平衡树

```cpp
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>   // 用tree
#include<ext/pb_ds/hash_policy.hpp>   // 用hash
#include<ext/pb_ds/trie_policy.hpp>   // 用trie
#include<ext/pb_ds/priority_queue.hpp>// 用priority_queue
using namespace __gnu_pbds;
---
#include<bits/extc++.h>
using namespace __gnu_pbds;
//bits/extc++.h与bits/stdc++.h类似，bits/extc++.h是所有拓展库，bits/stdc++.h是所有标准库
//=======================================================
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>

using namespace __gnu_pbds;
template<typename T>
using ordered_set = tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;

// rb_tree_tag 和 splay_tree_tag 选择树的类型(红黑树和伸展树)
T // 自定义数据类型
null_type//无映射（老版本g++为null_mapped_type）
less<T>//Node的排序方式从小到大排序
tree_order_statistics_node_update//参数表示如何更新保存节点信息 tree_order_statistics_node_update会额外获得order_of_key()和find_by_order()两个功能。

ordered_set<Node> Tree;  // Node 自定义struct 注意重载less
Tree.insert(Node);       // 插入
Tree.erase(Node);        // 删除
Tree.order_of_key(Node); // 求Node的排名:当前数小的数的个数 +1
Tree.find_by_order(k);   // 返回排名为k+1的iterator 即有k个Node比*it小
Tree.join(b);            // 将b并入Tree，前提是两棵树类型一致并且二没有重复元素
Tree.split(v, b);        // 分裂，key小于等于v的元素属于Tree，其余属于b
Tree.lower_bound(Node);  // 返回第一个大于等于x的元素的迭代器
Tree.upper_bound(Node);  // 返回第一个大于x的元素的迭代器

//以上的所有操作的时间复杂度均为O(logn)
//注意，插入的元素会去重，如set
ordered_set<T>::point_iterator it=Tree.begin();  // 迭代器
//显然迭代器可以++，--运算
```

维护 n 棵平衡树，启发式合并暴力合并。平衡树支持第 k 小

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/hash_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template<typename T>
using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
const int N = 500010;
int fa[N];
int n, m;
int find(int x) {
    return x == fa[x] ? x : fa[x] = find(fa[x]);
}
ordered_set<pair<int, int>> rt[N];
void merge(int u, int v) { // u < - v
    if (rt[u].size() < rt[v].size())
        swap(u, v);
    ordered_set<pair<int, int>>::point_iterator it = rt[v].begin();
    for (; it != rt[v].end(); it++) rt[u].insert(*it);
    rt[v].clear();
    fa[v] = u;
}
int main() {
    n = rd(), m = rd();
    for (int i = 1; i <= n; i++) rt[i].insert(pair<int, int>(rd(), i));
    for (int i = 1; i <= n; i++) fa[i] = i;

    while (m--) {
        int u = rd(), v = rd();
        u = find(u), v = find(v);
        if (u != v) merge(u, v);
    }
    int qc = rd();
    while (qc--) {
        char op[4];
        scanf("%s", op);
        int x = rd(), y = rd();
        if (op[0] == 'Q') {
            int u = find(x);
            if (rt[u].size() < y) puts("-1");
            else
                printf("%d\n", rt[u].find_by_order(y - 1)->second);
        } else {
            int u = find(x), v = find(y);
            if (u != v) merge(u, v);
        }
    }

    return 0;
}
```

